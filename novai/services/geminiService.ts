import { GoogleGenAI, Type } from "@google/genai";
import { AppState, Task, AnalysisReport } from "../types";

const getEnv = (key: string, fallback: string): string => {
  try {
    // @ts-ignore
    if (typeof import.meta !== 'undefined' && import.meta.env && import.meta.env[key]) {
      // @ts-ignore
      return import.meta.env[key];
    }
    if (typeof process !== 'undefined' && process.env && process.env[key]) {
      return process.env[key] as string;
    }
  } catch (e) {
    // Ignore errors
  }
  return fallback;
};

// The API key is read from VITE_GEMINI_API_KEY for Vite/Netlify builds, or API_KEY for other environments.
const API_KEY = getEnv('VITE_GEMINI_API_KEY', process.env.API_KEY || '');

let ai: GoogleGenAI | null = null;

// Initialize the AI client only if the API key is available.
if (API_KEY) {
  ai = new GoogleGenAI({ apiKey: API_KEY });
} else {
  console.warn("Gemini API Key not found. AI features will be disabled or use mock data.");
}

const isInvalidKeyError = (error: any): boolean => {
    const msg = error?.message?.toLowerCase() || '';
    return msg.includes('api key not valid') || msg.includes('invalid api key');
}

export const generateTasks = async (
  currentTasks: Task[],
  category: string,
  userLevel: number
): Promise<Partial<Task>[]> => {
  if (!ai) {
    // Fallback mock response if no API key
    return [
      { title: `Advanced ${category} Drill`, complexity: 'B', xpReward: 100, description: "Generated by NovaForge (Mock)" },
      { title: `${category} Mastery Session`, complexity: 'A', xpReward: 250, description: "Generated by NovaForge (Mock)" },
    ];
  }

  try {
    const model = 'gemini-2.5-flash';
    const prompt = `
      You are NovaForge AI, a System designed to evolve this user.
      User Level: ${userLevel} in "${category}".
      
      Generate 3 gamified, actionable tasks (Quests) for them.
      Context: They have ${currentTasks.length} pending tasks.
      
      Return ONLY a JSON array of objects with keys: title, complexity (E,D,C,B,A,S), xpReward (integer), description.
      No markdown formatting, just raw JSON.
    `;

    const response = await ai.models.generateContent({
      model,
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              title: { type: Type.STRING },
              complexity: { type: Type.STRING },
              xpReward: { type: Type.INTEGER },
              description: { type: Type.STRING },
            },
            required: ["title", "complexity", "xpReward", "description"],
          },
        },
      }
    });

    const text = response.text;
    if (!text) return [];
    
    return JSON.parse(text) as Partial<Task>[];
  } catch (error) {
    console.error("Gemini Gen Error:", error);
    if (isInvalidKeyError(error)) throw new Error('GEMINI_INVALID_KEY');
    return [];
  }
};

export const generateSubtasks = async (taskTitle: string, category: string): Promise<{title: string}[]> => {
    if (!ai) return [{ title: "Plan the steps" }, { title: "Execute phase 1" }, { title: "Review results" }];

    try {
        const prompt = `
            Task: "${taskTitle}" (Category: ${category}).
            Break this task down into 3-5 tactical, actionable sub-steps (max 6 words each).
            Return ONLY a JSON array of objects with key "title".
            Example: [{"title": "Research competitors"}, {"title": "Draft outline"}]
        `;

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: { 
                responseMimeType: "application/json",
                responseSchema: {
                  type: Type.ARRAY,
                  items: {
                    type: Type.OBJECT,
                    properties: {
                      title: { type: Type.STRING },
                    },
                    required: ["title"],
                  },
                },
            }
        });

        const text = response.text;
        if (!text) return [];
        return JSON.parse(text);
    } catch (error) {
        console.error("Subtask Gen Error", error);
        if (isInvalidKeyError(error)) throw new Error('GEMINI_INVALID_KEY');
        return [];
    }
};

export const analyzeProgress = async (state: AppState): Promise<string> => {
   if (!ai) return `System Online. Welcome back, ${state.user.name}. Sync complete. Keep grinding.`;

   try {
     const prompt = `
       The user is "${state.user.name}", Level ${state.user.level} (${state.user.rank}).
       Their Stats: ${JSON.stringify(state.user.stats)}.
       Their Streak: ${state.user.streak} days.
       
       Give a short, punchy, anime-style "System Message" (max 2 sentences) addressing them by name. 
       Acknowledge their rank or streak. Be motivating but cool (like a Jarvis or game system).
     `;
     
     const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt
     });

     return response.text || "System Error. Manual Override engaged.";
   } catch (e) {
     if (isInvalidKeyError(e)) throw new Error('GEMINI_INVALID_KEY');
     return "Connection to Shadow Realm unstable. Keep pushing.";
   }
};

export const getDetailedProfileAnalysis = async (state: AppState, imageBase64?: string): Promise<AnalysisReport> => {
  // Mock fallback
  if (!ai) {
    return {
      hunterClass: "Unknown Class",
      summary: "System offline. Unable to process deep scan. Please connect API Key.",
      vitalStatus: { status: "Stable", message: "Running on backup power." },
      keyStrengths: ["Resilience", "Curiosity"],
      weaknesses: ["Connectivity", "Data Sync"],
      recommendedFocus: "System Repair",
      tacticalAdvice: ["Connect to the network", "Obtain API Key", "Re-initiate scan"],
      projectedRankUp: "Indeterminate"
    };
  }

  try {
    const systemInstruction = `
      Act as "The System" from a leveling manhwa (like Solo Leveling). 
      You are analyzing Hunter: "${state.user.name}".
      
      Hunter Profile:
      - Bio: ${state.user.bio}
      - Goals: ${state.user.goals?.join(', ') || "None defined"}
      - Stats: ${JSON.stringify(state.user.stats)}
      - Deep Stats: ${JSON.stringify(state.deepStats)}
      - Projects: ${state.projects.map(p => p.title).join(', ')}
      - Task Activity: ${state.tasks.length} tasks recorded.
      
      ${imageBase64 ? 'An image of the user (physique or face) has been provided for biometric scanning.' : ''}

      Provide your analysis in the required JSON format based on the provided schema.
      
      Tone: Serious, Gamified, Anime-System style. Address the user directly if appropriate.
    `;

    const model = 'gemini-3-pro-preview'; // Using the requested model for high-quality analysis
    
    let contents: any;
    
    if (imageBase64) {
        contents = {
            parts: [
                { inlineData: { mimeType: 'image/jpeg', data: imageBase64 } },
                { text: `Analyze Hunter ${state.user.name}'s biometric data (image) and stats.` }
            ]
        };
    } else {
        contents = `Analyze Hunter ${state.user.name}'s statistical data.`;
    }

    const baseProperties: any = {
        hunterClass: { type: Type.STRING, description: "A creative class name based on their highest stats (e.g. Shadow Merchant, Iron Berserker, Tech Weaver)" },
        summary: { type: Type.STRING, description: `A 2-3 sentence analysis of ${state.user.name}'s current trajectory based on their specific goals.` },
        vitalStatus: { 
          type: Type.OBJECT,
          description: "Assessment of the user's current vitality.",
          properties: {
              status: { type: Type.STRING, description: "One of: Optimal, Stable, Critical, Fatigued" },
              message: { type: Type.STRING, description: "Short status reason based on streak/activity" },
          },
          required: ['status', 'message'],
        },
        keyStrengths: { type: Type.ARRAY, items: { type: Type.STRING }, description: "3 key strengths based on data" },
        weaknesses: { type: Type.ARRAY, items: { type: Type.STRING }, description: "3 areas lacking progress" },
        recommendedFocus: { type: Type.STRING, description: "The single most important category to focus on next" },
        tacticalAdvice: { type: Type.ARRAY, items: { type: Type.STRING }, description: "3 specific, actionable, gamified tips to improve immediately" },
        projectedRankUp: { type: Type.STRING, description: "Estimate when they might rank up based on current XP/Level" },
      };
  
      if (imageBase64) {
          baseProperties.physiqueAnalysis = {
              type: Type.OBJECT,
              description: "Analysis of user's physique from the provided image.",
              properties: {
                  rank: { type: Type.STRING, description: "S|A|B|C|D|E (Physique Rank)" },
                  estimatedBodyFat: { type: Type.STRING, description: "Estimate range percentage" },
                  muscleSymmetry: { type: Type.STRING, description: "Analysis of proportions and symmetry" },
                  aestheticsScore: { type: Type.INTEGER, description: "0-100 (Integer score)" },
                  potentialClass: { type: Type.STRING, description: "Best suited RPG class based on build (e.g. Tank, Ranger, Assassin)" },
                  strengths: { type: Type.ARRAY, items: { type: Type.STRING }, description: "Visible strengths" },
                  weaknesses: { type: Type.ARRAY, items: { type: Type.STRING }, description: "Visible areas to improve" },
                  improvementPlan: { type: Type.ARRAY, items: { type: Type.STRING }, description: "3 specific exercises or aesthetic tips" },
              },
              required: ['rank', 'estimatedBodyFat', 'muscleSymmetry', 'aestheticsScore', 'potentialClass', 'strengths', 'weaknesses', 'improvementPlan'],
          };
      }
      
      const schema = {
          type: Type.OBJECT,
          properties: baseProperties,
          required: Object.keys(baseProperties),
      };

    const response = await ai.models.generateContent({
      model,
      contents,
      config: {
        systemInstruction,
        responseMimeType: "application/json",
        responseSchema: schema,
      }
    });

    const text = response.text;
    if (!text) throw new Error("No response from AI");

    return JSON.parse(text) as AnalysisReport;
  } catch (error) {
    console.error("Deep Scan Error:", error);
    if (isInvalidKeyError(error)) throw new Error('GEMINI_INVALID_KEY');
    return {
      hunterClass: "Glitch Walker",
      summary: "An anomaly occurred during the system scan.",
      vitalStatus: { status: "Critical", message: "Analysis Subroutine Failed" },
      keyStrengths: [],
      weaknesses: [],
      recommendedFocus: "Debugging",
      tacticalAdvice: ["Check internet connection", "Retry scan later"],
      projectedRankUp: "Unknown"
    };
  }
};